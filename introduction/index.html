<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Introduction To Hazelcast · Tom O'Connell</title><meta name="description" content="Introduction To Hazelcast - Tom O'Connell"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/tom_logo.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Tom O'Connell"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/tom_logo.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/tomoconnell" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Introduction To Hazelcast</h1><div class="post-info">Jul 13, 2018</div><div class="post-content"><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><h2 id="Hazelcast-Briefly"><a href="#Hazelcast-Briefly" class="headerlink" title="Hazelcast, Briefly"></a>Hazelcast, Briefly</h2><p>Really briefly, Hazelcast is a clustered, in-memory data-grid that uses partitioning for data distribution and supports monitoring.</p>
<h3 id="Clustered"><a href="#Clustered" class="headerlink" title="Clustered"></a>Clustered</h3><p>Clustering refers to how some network-centric software remains resilient and highly available. Because of the clustering — i.e. the discovery process — you can just start processes, either members or clients, as you need and they find each other and form a consistent whole. Members join, the load spreads out; members terminate and the load is absorbed by the others.</p>
<h3 id="In-Memory"><a href="#In-Memory" class="headerlink" title="In Memory"></a>In Memory</h3><p>The sweet spot of in-memory storage — obviously — is purely in-memory. This is an ideal use-case for Hazelcast. You can scale the storage in a number of ways and they all work well. For the open-source edition, you pick your JVM size, based upon your own testing and tuning (there are no good portable recommendations for that). You pick your backups; you’ll rarely need to go off the default (1) backup for in-memory storage. </p>
<h3 id="Data-Grid"><a href="#Data-Grid" class="headerlink" title="Data Grid"></a>Data Grid</h3><p>It’s a data grid. That means a lot of different things and marketing terminology can obscure this, but basically, it’s data held in caches that is available for retrieval by members or clients; processing — either in-place or in different processes — that can support events, triggers, transformations and basically, anything you can think up and code.<br>The tools available in this grid are the most robust among IMDG frameworks. Vendors in this space all support some flavor of map or cache, but this tool provides a really wide array of distributed processing possibilities. There are maps, queues, lists, sets — all extending the collections classes. There are also RingBuffers and Multimaps. Alongside queues, there are topics — and even reliable topics — for more messaging options. The available concurrency utilities include locks, semaphores, atomic-longs, atomic-references, the id-generator and a countdown-latch. CRDTs (conflict free replicated data-types) are being added, starting with the PN-counter. there really isn’t any competition in this area.</p>
<h3 id="With-Partitioning"><a href="#With-Partitioning" class="headerlink" title="With Partitioning"></a>With Partitioning</h3><p>Partitioning — sometimes called sharding — is a horizontal partitioning of data across multiple member processes. You can think of the Hazelcast partitions (shards) as the hash buckets of a distributed hash map. Each cluster uses a configured number of partitions — the default is 271 and that often need not be changed. A single member “cluster” (non-clustered cluster?) would get all the partitions, without backups. As the first member joins, roughly half the partitions are transferred to that new member and backups are created at that time. As each subsequent member joins, some basically equal fraction of the partitions are transferred to that member — both primary data and backups.<br>When members leave, the backups are promoted to primary partitions and new backups are created on the remaining members.</p>
<h3 id="And-Monitoring"><a href="#And-Monitoring" class="headerlink" title="And Monitoring"></a>And Monitoring</h3><p>One might argue that monitoring doesn’t belong here, but within distributed systems the lack of monitoring is a huge step toward failure. Headless systems are often not well understood and sometimes ignored by ops — and who can blame them. Ops can only react to errors after they occur, where monitoring might highlight problems before.<br>Hazelcast uses JMX  to support the <em>Management Center</em>, so monitoring is easily available; you see issues coming in advance of major problems and — better yet — supports alerting thresholds that will allow the system to call for help.<br>You can also easily integrate this with a log file management and analysis, like the open-source ELK (elasticsearch/logstash/kibana) — or one of the excellent commercial alternatives.</p>
<h3 id="What’s-it-for"><a href="#What’s-it-for" class="headerlink" title="What’s it for?"></a>What’s it for?</h3><p>It’s for almost any programming task — broadly speaking, but the three major areas are caching, distributed processing and distributed messaging. The central theme of all the applications is big, fast data. Big data is good, big fast data is awesome. Hazelcast has been around long enough to have serious adoption in various industries — airlines, telcos, finance, crypto currency applications and on and on. Does it need to be big? Not really — it’s nice to have an infrastructure that can start small and grow enormously.<br>The processing capabilities have been enormously augmented by Jet — fast stream and batch processing, built on top of the IMDG. That’s a deep topic, all on its own — and will be covered in many other places.</p>
<h3 id="Before-you-start"><a href="#Before-you-start" class="headerlink" title="Before you start"></a>Before you start</h3><p>There are only a few things you need, to get going -</p>
<h4 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h4><p>Java 8 is probably the most widely used jdk/jre right now and is the preferred one to start with. If you have v3.10+, jdk9 is fine, too. For simplicity, though, I’ll assume jdk8.</p>
<h4 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h4><p>Eclipse, IntelliJ and NetBeans seem to make up about 97% of the IDE users and any of them work well with Hazelcast/maven. If you’re not using an IDE, you may want to re-think what you’re doing. The sample code in the github repo was tested in eclipse, as well as from the command line, so it’s an easy import.</p>
<h4 id="Gradle-or-Maven"><a href="#Gradle-or-Maven" class="headerlink" title="Gradle or Maven"></a>Gradle or Maven</h4><p>These are popular build tools for java environments, use these, or choose your own.</p>
<h4 id="Hazelcast-Dependencies"><a href="#Hazelcast-Dependencies" class="headerlink" title="Hazelcast Dependencies"></a>Hazelcast Dependencies</h4><p>All the dependencies for Hazelcast — any edition — are available on public maven repositories or from the download site. You can download the open-source code, too, for that matter.</p>
<h5 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h5><p>The server jar will be in one of two forms: ‘hazelcast’ or ‘hazelcast-all’ (which also includes client dependencies).</p>
<h5 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h5><p>The Hazelcast client is generally included from ‘hazelcast-client’, and that’s the only addition to your client app build.</p>
<h3 id="Programming-Models"><a href="#Programming-Models" class="headerlink" title="Programming Models"></a>Programming Models</h3><p>Hazelcast is a toolkit — that’s a really important point. There are common patterns you can employ, but — really — it’s just java. You’re not constrained to any set architecture. You can design your own infrastructure to meet your needs in any way you see fit. Here are some common deployment models.</p>
<h4 id="Embedded-Member"><a href="#Embedded-Member" class="headerlink" title="Embedded Member"></a>Embedded Member</h4><p>Embedded members are really the easiest way to get started and, for some things they may be all that you need. An embedded client is a java program, where you create a <code>HazelcastInstance</code>. That will launch the framework and form a cluster with any compatibly configured members they find on the network — that all depends upon your network and discovery configuration.</p>
<h4 id="Dedicated-Member"><a href="#Dedicated-Member" class="headerlink" title="Dedicated Member"></a>Dedicated Member</h4><p>A dedicated member is a Hazelcast process dedicated to storage and a few other things. It won’t run your code, except for server-side-specific constructs — entry processors, Executor Tasks (Callables and Runnables), event code (Listeners and Interceptors) and persistence code (MapLoader and MapStore).<br>The advantage of this approach over the embedded model is that its scalability will always become more important than simplicity. With this, you can scale your storage fleet separately from your client fleet. If your storage demands soar, but the processing doesn’t, you just scale these members. If you introduce new processing demands for the same, or similar, data loads, you just add clients.<br>In general, this is going to be the best basic approach to almost any IMDG system.</p>
<h4 id="Lite-Member"><a href="#Lite-Member" class="headerlink" title="Lite Member"></a>Lite Member</h4><p>Lite members are interesting — they join the cluster — unlike clients that just make a client-specific TCP connection. The do not, however, host data. They are for a small number of kinda advanced things — they may be used for class-loading or they may be used as high-performance compute clients. You could, for example direct runnable and callable tasks to Lite members — if they require data that’s spread across the cluster for some kind of computation or processing.</p>
<h4 id="Clients"><a href="#Clients" class="headerlink" title="Clients"></a>Clients</h4><p>Hazelcast clients are programs that connect to an IMDG and interacts using either REST or a native client library. These will be in your web-clients, your command-line tools or anything that iteracts with Hazelcast. Don’t think, though, that because they’re clients, you’re going to be doing all your processing there. Well written clients will use server-side constructs — particularly entry-processors, aggregation and executor tasks — to delegate processing requests from (what could be) single-threaded clients onto a (what should be) massively scalable clustered storage and processing environment.<br>Not everything will be delegated to the back-end, of course. Many, many clients simply require extremely low-latency access to fast, big data that isn’t changed too often and isn’t changed (ideally) by separate clients (i.e. sticky sessions are good). For these, <em>near-caches</em> are extremely effective. Near-caches allow each member to host — within its process space — potentially large sub-sets of data that are being actively managed by the cluster. These are supported in all editions of Hazelcast, but it’s worth noting that the <em>Enterprise HD</em> edition will allow off-heap near-caches, giving you low latency access to — potentially — many gigabytes of near-cache data in each client. This has a broad range of applications across industries; real-time inventory for e-commerce and fraud-detection for credit-card processors are two interesting ones. Note that in neither of these, is the data static — that’s not a requirement. But the data is read much more often than it’s changed, making both of these ideal cases for near-caching.</p>
<h3 id="A-Simple-Java-Cluster-Member"><a href="#A-Simple-Java-Cluster-Member" class="headerlink" title="A Simple Java Cluster Member"></a>A Simple Java Cluster Member</h3><p>So, finally a little code. Starting Hazelcast from Java is easy. In this example, we set up the configuration in code; we could also have let it search the classpath for an XML file (hazelcast.xml). This is done to more clearly demonstrate what’s happening.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJavaServer</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger l = LoggerFactory.getLogger(SimpleJavaServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        Object memberLock = <span class="keyword">new</span> Object();</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        NetworkConfig networkConfig = config.getNetworkConfig();</span><br><span class="line">        JoinConfig joinConfig = networkConfig.getJoin();</span><br><span class="line">        <span class="comment">// disable multicast (the default join strategy)</span></span><br><span class="line">        joinConfig.getMulticastConfig().setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// AWS join config is off by default, so this is only illustrative.</span></span><br><span class="line">        joinConfig.getAwsConfig().setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        TcpIpConfig tcpIpConfig = joinConfig.getTcpIpConfig();</span><br><span class="line">        tcpIpConfig.setEnabled(<span class="keyword">true</span>).addMember(<span class="string">"127.0.0.1,127.0.0.2,127.0.0.3"</span>);</span><br><span class="line">	</span><br><span class="line">        HazelcastInstance instance =</span><br><span class="line">            Hazelcast.newHazelcastInstance(config);</span><br><span class="line">        LifecycleService service = instance.getLifecycleService();</span><br><span class="line">        service.addLifecycleListener(</span><br><span class="line">	    <span class="keyword">new</span> MemberLifecycleListener(memberLock));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (memberLock)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">              &#123;</span><br><span class="line">                memberLock.wait(<span class="number">3000L</span>);</span><br><span class="line">                instance.shutdown();</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">              &#123;</span><br><span class="line">                l.error(<span class="string">"while waiting for cluster to shut down (&#123;&#125;): exiting"</span>,</span><br><span class="line">                      e.getMessage());</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberLifecycleListener</span> <span class="keyword">implements</span> <span class="title">LifecycleListener</span></span></span><br><span class="line"><span class="class">      </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object memberLock;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MemberLifecycleListener</span><span class="params">(Object memberLock)</span></span></span><br><span class="line"><span class="function">          </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.memberLock = memberLock;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(LifecycleEvent event)</span></span></span><br><span class="line"><span class="function">          </span>&#123;</span><br><span class="line">            LifecycleState currState = event.getState();</span><br><span class="line">            <span class="keyword">switch</span> (currState)</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">case</span> SHUTTING_DOWN:</span><br><span class="line">                  l.warn(<span class="string">"cluster is shutting down"</span>);</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> SHUTDOWN:</span><br><span class="line">                  l.warn(<span class="string">"cluster shutdown complete - will notify member"</span>);</span><br><span class="line">                  <span class="keyword">synchronized</span> (memberLock)</span><br><span class="line">                    &#123;</span><br><span class="line">                      memberLock.notify();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                  l.info(<span class="string">"member state is now: &#123;&#125;"</span>, currState);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Most of that code was the event listener. Without the wait/notify (or any other) mechanism, this would create the member instance — and exit. Instead, it waits 3 sec and calls shutdown - to exercise the lifecycle listener. Notice that the listener isn’t added until the member is started, so the only events you should see are the _SHUTTING_DOWN_, immediately followed by <em>SHUTDOWN</em>. To make this work with clients, remove the time from the wait.</p>
<h3 id="A-Simple-Client"><a href="#A-Simple-Client" class="headerlink" title="A Simple Client"></a>A Simple Client</h3><p>We can do a really simple client — without Spring boot — just by creating a client instance. The server (above) should be running, and the client instance in this code will give you access to the all the features of the IMDG. This client will work with the above server, but make sure you change or remove the argument to <code>wait()</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClient</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger l = LoggerFactory.getLogger(SimpleClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        ClientConfig config = <span class="keyword">new</span> ClientConfig();</span><br><span class="line">        config.getNetworkConfig().addAddress(<span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line">        GroupConfig groupConfig = config.getGroupConfig();</span><br><span class="line">        groupConfig.setName(<span class="string">"dev"</span>);</span><br><span class="line">        groupConfig.setPassword(<span class="string">"dev-pass"</span>);</span><br><span class="line"></span><br><span class="line">        HazelcastInstance client = HazelcastClient.newHazelcastClient(config);</span><br><span class="line"></span><br><span class="line">        IMap&lt;String, String&gt; demo = client.getMap(<span class="string">"demo"</span>);</span><br><span class="line"></span><br><span class="line">        String key = <span class="string">"someKey"</span>;</span><br><span class="line"></span><br><span class="line">        demo.set(key, <span class="string">"some value"</span>);</span><br><span class="line"></span><br><span class="line">        l.info(<span class="string">"demo map (size &#123;&#125;) contains value &#123;&#125; for key &#123;&#125;"</span>, demo.size(), demo.get(key), key);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>That’s a very simple demo — but, it sets up a client that looks for a server-member instance on the same host you specify, connects to it and manipulates data in a distributed map. Not bad, for that much code- IMHO.</p>
<h3 id="A-Simple-Spring-Boot-Cluster-Member"><a href="#A-Simple-Spring-Boot-Cluster-Member" class="headerlink" title="A Simple Spring Boot Cluster Member"></a>A Simple Spring Boot Cluster Member</h3><p>So, finally a little code. All of this is on github, so you can look at the POM (pom.xml) file there. It’s really basic, you need the spring-boot parent entry and just the Hazelcast dependency (from above).<br>Make your main class a spring boot application with the <code>@SpringBootApplication</code> annotation. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSpringBootServer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    &lt;snip&gt;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        SpringApplication.run(SimpleSpringBootServer.class, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;snip&gt;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>That’s a fairly concise server. The instance it’s going to use is injected. This server will terminate when the application context<br>is closed.<br>In this example, the config is wrapped in beans — </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(&#123;<span class="string">"server"</span>, <span class="string">"java-config"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaServerConfig</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">commandLineRunner</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">          applicationContext.getBean(<span class="string">"hazelcastInstance"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JoinConfig <span class="title">joinConfig</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        JoinConfig config = <span class="keyword">new</span> JoinConfig();</span><br><span class="line">        config.getMulticastConfig().setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        config.getAwsConfig().setEnabled(<span class="keyword">false</span>);</span><br><span class="line">        config.getTcpIpConfig().setEnabled(<span class="keyword">true</span>);</span><br><span class="line">        config.getTcpIpConfig().addMember(<span class="string">"127.0.0.1,127.0.0.2,127.0.0.3"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NetworkConfig <span class="title">networkConfig</span><span class="params">(JoinConfig joinConfig)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        NetworkConfig config = <span class="keyword">new</span> NetworkConfig();</span><br><span class="line"></span><br><span class="line">        config.setJoin(joinConfig);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"config"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Config <span class="title">config</span><span class="params">(NetworkConfig networkConfig)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"hazelcastInstance"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HazelcastInstance <span class="title">hazelcastInstance</span><span class="params">(Config config)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        HazelcastInstance instance = Hazelcast.newHazelcastInstance(config);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(<span class="keyword">final</span> HazelcastInstance instance)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        CacheManager manager = <span class="keyword">new</span> HazelcastCacheManager(instance);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Spring Boot will create a default instance of Hazelcast — that’s fine, especially if you’re using declarative configuration (XML), but<br>for java config, this an effective approach.</p>
<h4 id="A-Slightly-Better-Client"><a href="#A-Slightly-Better-Client" class="headerlink" title="A Slightly Better Client"></a>A Slightly Better Client</h4><p>We can do more with the client code. I’m doing this all as Spring Boot, so it would make sense to have a simple executable, where the app logic is in a bean —</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientApp</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    &lt;snip&gt;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        SpringApplication.run(ClientApp.class, args);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">commandLineRunner</span><span class="params">(ApplicationContext context)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">          HazelcastInstance client = (HazelcastInstance) context.getBean(<span class="string">"clientInstance"</span>);</span><br><span class="line"></span><br><span class="line">          IMap&lt;String, String&gt; demo = client.getMap(<span class="string">"demo"</span>);</span><br><span class="line"></span><br><span class="line">          String key = <span class="string">"someKey"</span>;</span><br><span class="line"></span><br><span class="line">          demo.set(key, <span class="string">"some value"</span>);</span><br><span class="line"></span><br><span class="line">          l.info(<span class="string">"demo map (size &#123;&#125;) contains value &#123;&#125; for key &#123;&#125;"</span>, demo.size(), demo.get(key), key);</span><br><span class="line">          System.out.println(<span class="string">"in main --- args len: "</span> + args.length);</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;snip --- boilerplate&gt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>This version of nearly the same code uses DI to hand us a configured Hazelcast client instance. That allows us enormous flexibility in deciding where/how to configure it and lets us use environment-specific configuration, too. In real code, the configuration would be moved out of the app class, but this is easily readable.</p>
<h5 id="Simple-Map-Access"><a href="#Simple-Map-Access" class="headerlink" title="Simple Map Access"></a>Simple Map Access</h5><p>This part is easy — a Hazelcast IMap <code>is a</code> java.util.Map — so you can take existing code for the java collections API and just repurpose it. Not to go too far astray, but here’s a little code showing how easy that can be.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"isAMapRunner"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsAMapRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span>, <span class="title">ApplicationContextAware</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    &lt;snip&gt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateMap</span><span class="params">(Map&lt;String, String&gt; map)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">          &#123;</span><br><span class="line">            String key = <span class="string">"k-"</span> + i;</span><br><span class="line">            String value = <span class="string">"Value: "</span> + i;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * create a java util map and do something with it -</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        populateMap(map);</span><br><span class="line">        l.info(<span class="string">"size of the java collections map is &#123;&#125;"</span>, map.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * now, let's talk to the IMDG --- Get a reference to an IMap, but</span></span><br><span class="line"><span class="comment">         * refer to it as a collections Map. Can't use distributed  functions, though.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        HazelcastInstance instance = (HazelcastInstance) getApplicationContext().getBean(<span class="string">"hazelcastInstance"</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Use the same map declaration</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        map = instance.getMap(<span class="string">"employees"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This may be empty --- but, it may have been populated in other</span></span><br><span class="line"><span class="comment">         * code --- that's the biggest difference here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        l.info(<span class="string">"distributed map size is &#123;&#125; initially"</span>, map.size());</span><br><span class="line">        populateMap(map);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The size may have changed. (If the keys were identical,</span></span><br><span class="line"><span class="comment">         * 'populateMap' would have just overwritten existing values and</span></span><br><span class="line"><span class="comment">         * not changed the size).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        l.info(<span class="string">"distributed map size is &#123;&#125; after being populated"</span>, map.size());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &lt;snip&gt;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>In that bit, there’s a method that creates a map and uses it — sort of trivially, but it’s working code.<br>In the second part, the only change was to use the injected Hazelcast instance (injected, via annotation), to get a reference to a distributed map in the IMDG. There’s no magic; Hazelcast is designed so that you can swap it in that easily, using the — <em>really better be</em> — familiar collections API. But, back to that comment for a second — should the declaration have been IMap, not Map? It depends — it could be, but it doesn’t need to be. Hazelcast maps implement the java.util implements, so that’s valid — but maybe not useful. In a minute, we’re going to use some Hazelcast specific methods on the map and to make those visible, you’d want to change the declaration. If you’re just doing put, get, size, remove and all of those, then no. One interesting note on that: it’s easy to forget that <figure class="highlight plain"><figcaption><span>returns the old mapping, as it inserts the new. I don't think I've ever actually seen code that used that, but, there it is. Think about that in a network environment, though --- when you do a `put`, Hazelcast --- conforming to the contract --- returns the old mapping. Over the network. Incurring serialization. For no reason. Because nobody. Ever. Looks. At. It. Hazelcast has added a `set` method, that works like `put`, save that it doesn't return the value. This may seem like small stuff, but think about a heavily utilized production environment, getting a surge of requests; you're busy and half of that flavor of network traffic is stuff you're never going to look at. Change two letters in your code and the network traffic drops --- significantly. I'd do it.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">In moving from a collections map to a distributed map, keep in mind, however, that there are differences. With a distributed map, absent security configuration, other clients/other threads can use the same map. If you test the size of a new in process map, that you create in your thread, the size will be `0`. When you get a reference to a distributed collection from the IMDG, it will create it --- if required --- or return a reference to an existing collection, if it&apos;s already been created. This can be a very powerful feature --- you can pre-populate a collection, from a persistent store or any other data-source. Your client code will be smaller and simpler, because you can make assumptions about it. If you&apos;re using a map for a scratchpad cache, however, keep in mind that you may want to create unique map instances or manage data, so that your thread doesn&apos;t collide with other clients.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### Near Cache Access</span><br><span class="line">Hazelcast supports second-level (edge) caching in client processes and refers to it as &quot;near caching&quot;. Near caches are almost transparent to your code --- although there are things you need to be aware of.</span><br><span class="line">Each mapping in the near cache is, fundamentally, managed by the IMDG member that owns the &quot;master&quot; copy of the data. It may be cached on multiple clients --- in multiple apps --- and each caching client app may define their own policy for managing updates. The data in your near cache may be stale --- you probably shouldn&apos;t cache things for overly long times (you set the expiry interval in config). You should be careful about using near caches for things that are updated frequently and very careful about using them for things that are updated from multiple points. For a web application with sticky sessions, you should be able to count on certain objects being in only one client process --- that&apos;s a good scenario. </span><br><span class="line"></span><br><span class="line">#### Simple Query Operations</span><br><span class="line">##### SQL Queries</span><br><span class="line">Hazelcast is not a SQL database or --- _really_ --- a SQL query tool, but it provides a very workable, robust subset of SQL query functionality. It&apos;s very accessible for developers. If you have a SQL background, this is nothing; if you don&apos;t, it&apos;s still pretty intuitive. The SqlPredicate encapsulates the &quot;where&quot; clause of a query. For IMDG data extraction, that&apos;s probably the part you really care about. Having said that it&apos;s not a relational database, I should point out that, since you&apos;re generally dealing with purely in memory data, this is going to be very fast.</span><br><span class="line"></span><br><span class="line">I think that shows how easy it is to bridge a SQL background, with the IMDG SQL-like query. The big caveat here is joins; out of the box, the IMDG is not a really good tool for joins, because of the nature of the data. We split it up because it&apos;s big data; because it&apos;s big data, joining it back together is a more specialized thing. Hazelcast IMDG can certainly do joins, but Hazelcast Jet is a more appropriate tool.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### Predicate Queries --- Criteria API</span><br><span class="line">For Java developers who really never liked SQL (lots of us) there&apos;s also a pure java approach to querying the IMDG: the criteria API.</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Component(&quot;predicateQueryRunner&quot;)</span><br><span class="line">public class ClientPredicateQueryRunner implements CommandLineRunner, ApplicationContextAware</span><br><span class="line">  &#123;</span><br><span class="line">    &lt;snip&gt;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws Exception</span><br><span class="line">      &#123;</span><br><span class="line">        HazelcastInstance client = (HazelcastInstance) applicationContext.getBean(&quot;clientInstance&quot;);</span><br><span class="line"></span><br><span class="line">        IMap&lt;Long, Employee&gt; employees = client.getMap(&quot;employees&quot;);</span><br><span class="line">        Employee a = new Employee(Long.valueOf(1), &quot;Jane&quot;, &quot;Doe&quot;);</span><br><span class="line">        Employee b = new Employee(Long.valueOf(2), &quot;John&quot;, &quot;Smith&quot;);</span><br><span class="line">        Employee c = new Employee(Long.valueOf(3), &quot;Tom&quot;, &quot;Notmyrealname&quot;);</span><br><span class="line">        Employee d = new Employee(Long.valueOf(4), &quot;Tom&quot;, &quot;FakeName&quot;);</span><br><span class="line">        Employee e = new Employee(Long.valueOf(5), &quot;Tom&quot;, &quot;ActualName&quot;);</span><br><span class="line">        employees.set(a.getEmpId(), a);</span><br><span class="line">        employees.set(b.getEmpId(), b);</span><br><span class="line">        employees.set(c.getEmpId(), c);</span><br><span class="line">        employees.set(d.getEmpId(), d);</span><br><span class="line">        employees.set(e.getEmpId(), e);</span><br><span class="line"></span><br><span class="line">        Predicate&lt;String, String&gt; fnamePredicate = equal(&quot;firstName&quot;, &quot;Tom&quot;);</span><br><span class="line">        Collection&lt;Employee&gt; employeesNamedTom = employees.values(fnamePredicate);</span><br><span class="line"></span><br><span class="line">        l.info(&quot;found &#123;&#125; employees named &apos;Tom&apos;&quot;, employeesNamedTom.size());</span><br><span class="line"></span><br><span class="line">        Predicate&lt;String, String&gt; lnamePredicate = equal(&quot;lastName&quot;, &quot;ActualName&quot;);</span><br><span class="line">        Predicate actNamePredicate = and(fnamePredicate, lnamePredicate);</span><br><span class="line"></span><br><span class="line">        l.info(&quot;&#123;&#125; emploees match first and last name&quot;, employees.values(actNamePredicate).size());</span><br><span class="line">      &#125;</span><br><span class="line">      &lt;snip - boilerplate&gt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>It’s probably obvious — but let me talk about what that’s doing. From a client, you’re setting up arbitrarily complex criteria — in both the SQL and the criteria APIs — and dispatching the evaluation to the grid. This is very powerful, because the queries are distributed across hardware. I’ve seen people do things like bring the entire map to a client, to iterate over it, for reasons. Bad reasons. With Hazelcast, you describe what you want back and dispatch the evaluation and extraction to your entire server fleet, seeing only correct results. This is a reporting or analysis kind of thing — you wouldn’t look up everyone whose last name starts with “D”, to do any kind of processing where the employee object would be updated, of course.<br>Does the query capability make the IMDG a database? Nope. Does it give you highly leveraged tools for fast access to big data? Yep. </p>
<p>One thing that, looking at this, really needs to be mentioned, if only briefly, is memory in the query client. I’ve described Hazelcast as a fast big-data framework, so clearly, the query operations can quickly retrieve very large volumes of data. If you had, say 20 storage members and queried the cluster and brought back 1GB, or so, of data from each, you’d be looking at 20GB of data from one query. You may, or may not, have that much memory available in your client. The fix for that is paging-predicates. These predicates wrap (logically subsume) other predicates, so that you get the same logical comparisons — the same filtering — wrapped in a container that lets you bring results back in batch sizes that you specify — it’s as though you’re reading a printed book and seeing one page at a time.</p>
<h5 id="Entry-Processors"><a href="#Entry-Processors" class="headerlink" title="Entry Processors"></a>Entry Processors</h5><p>Entry processors are really pretty cool — you can do highly efficient in-place processing with a minimum of locking. Consider what people often end up doing to work with remote objects — lock a key, fetch the value, mutate the value, put it back then (in a finally block, I hope) unlock the key. That’s four network calls, to start with — three if you’re only looking at the data and not updating the central source. Your objects may be large and incur significant cost in terms of CPU and network for serialization and transport. They may not, but I’m trying to make a point.<br>Entry processors allow you to dispatch a key-based ‘task’ object across the LAN — directly to the member owning a key, where it is executed in a lock-free, thread-safe fashion. Too good to be true? Not really — Hazelcast has an interesting threading model that allows this to happen. That’s a topic worth its own discussion, too, so take my word for it, for now.</p>
<p>Here’s a brain dead simple entry processor example — but it’s still a really useful approach:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"client"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryProcessorRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span>, <span class="title">ApplicationContextAware</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line"></span><br><span class="line">        HazelcastInstance instance = (HazelcastInstance) applicationContext.getBean(<span class="string">"hazelcastInstance"</span>);</span><br><span class="line">        IMap&lt;String, String&gt; demo = instance.getMap(<span class="string">"demo"</span>);</span><br><span class="line"></span><br><span class="line">        String key = <span class="string">"someKey"</span>;</span><br><span class="line">        demo.set(key, <span class="string">"Just a String value..."</span>);</span><br><span class="line"></span><br><span class="line">        demo.executeOnKey(key, <span class="keyword">new</span> DemoEntryProcessor());</span><br><span class="line"></span><br><span class="line">        EntryProcessor&lt;String, String&gt; asyncProcessor = <span class="keyword">new</span> DemoOffloadableEntryProcessor();</span><br><span class="line"></span><br><span class="line">        demo.submitToKey(key, asyncProcessor);</span><br><span class="line">        ExecutionCallback&lt;String&gt; callback = <span class="keyword">new</span> AsynchCallbackDemo();</span><br><span class="line"></span><br><span class="line">        demo.submitToKey(key, asyncProcessor, callback);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &lt;snip&gt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Here’s the entry processor that is called in this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoEntryProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractEntryProcessor</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt;</span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    &lt;snip&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String FMT = <span class="string">"This value (%s) was modified at -- %s"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Entry&lt;String, String&gt; entry)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        String key = entry.getKey();</span><br><span class="line">        String value = entry.getValue();</span><br><span class="line">        l.info(<span class="string">"in-place processing called for &#123;&#125;::&#123;&#125;"</span>, key, value);</span><br><span class="line"></span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(dtFormat);</span><br><span class="line">	String dt = sdf.format(<span class="keyword">new</span> Date())</span><br><span class="line">        entry.setValue(String.format(FMT, dt, value));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;snip&gt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>I’m describing the simplest case, but as simple as it is, this is a very powerful tool to have. From your client, you can dispatch computation to your servers, no explicit locking, no worrying about thread-safety, efficient user of the LAN. But because you’re synchronously waiting for the result to be returned, it may not seem like a really big deal. Hazelcast also has a number of options to run synchronously, asynchronously and on multiple entries.</p>
<p>This is a really useful set of calls. The first one, <code>executeOnKey</code>, does exactly that; it makes one direct call to the key owner and executes synchronously on that entry. The next two execute asynchronously — your client code doesn’t need to wait for long running operations. A word of warning, though: long running entry-processors can be truly evil — use off-loadable in your code, by annotation, to tell Hazelcast to move the operation off of the default threading structure.</p>
<p>Here’s the async processor, similar in function to the first:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoOffloadableEntryProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractEntryProcessor</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; <span class="keyword">implements</span> <span class="title">Offloadable</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    &lt;snip&gt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String FMT = <span class="string">"This value (%s) was modified at -- %s"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String  OFFLOADABLE_EXECUTOR  = <span class="string">"default"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Entry&lt;String, String&gt; entry)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        String key = entry.getKey();</span><br><span class="line">        String value = entry.getValue();</span><br><span class="line">        l.info(<span class="string">"in-place processing called for &#123;&#125;::&#123;&#125;"</span>, key, value);</span><br><span class="line"></span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(dtFormat);</span><br><span class="line">	String dt = sdf.format(<span class="keyword">new</span> Date())</span><br><span class="line">	</span><br><span class="line">        entry.setValue(String.format(FMT, dt, value));</span><br><span class="line">        entry.setValue(newValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newValue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getExecutorName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> OFFLOADABLE_EXECUTOR;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>I like this one: submit the processing, tag it with a callback and be on your way. Where would you use that? Broad question — it really depends — but if you have a stream of data requests that need to be initiated without the caller needing to wait for a result, this may be perfect. If you’re going to do this, be sure to read ahead to the section on back-pressure.</p>
<p>The execution callback executes in the caller’s process space, so it’s your notification that the invocation is complete. This one just logs, like this:</p>
<h5 id="Back-Pressure"><a href="#Back-Pressure" class="headerlink" title="Back Pressure"></a>Back Pressure</h5><p>Back-pressure is a topic worth some consideration, if you’re using asynchronous operations. The settings to consider are: the number of simultaneous async operations, the client timeout and the <em>syncwindow</em>.</p>
<p>When you have a need and are ready to test, configuring it can be done with system properties, like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Dhazelcast.backpressure.enabled=<span class="keyword">true</span></span><br><span class="line">-Dhazelcast.backpressure.backoff.timeout.millis=<span class="number">60000</span></span><br><span class="line">-Dhazelcast.backpressure.max.concurrent.invocations.per.partition=<span class="number">100</span></span><br><span class="line">-Dhazelcast.backpressure.syncwindow=<span class="number">1000</span></span><br></pre></td></tr></table></figure>
<p>First, we enable backpressure - this should always be done for async.<br>Hazelcast is using its threads to execute these, so there’s a limit to how many invocations can be in flight at any one point in time. The absolute number doesn’t matter — that would depend upon the size of your cluster and the number of CPUs/cores/physical threads. What’s  likely to be interesting is how many can be queued up for one partition — by default, mutating entry-processors operate on a “partition thread”. Hazelcast will examine the hardware resources available and dynamically allocate thread pools at runtime. You rarely need to configure threading for your IMDG.</p>
<p>First, we just just enable backpressure — we could do that and just take all the defaults or we can configure more about it. The second property (timeout) is the max wait (millis) for an invocation space to be available. The third controls the number of pending operations per partition. With asynch operations, Hazelcast will periodically convert one operation from async to sync — and the last property controls that. In the above example, about 1 in 1,000 operations (it’s randomized +- 25%) will be converted to a synch call and that caller waits while the queue — if any — of operations is drained.</p>
<p>The client-side analogue of back pressure are concurrent invocations (which can be managed by the system property <code>hazelcast.client.max.concurrent.invocations</code>). This limits the pressure that a client can generate on the server. Use of asynchronous client calls — <code>getAsync()</code>, <code>putAsync()</code>, <code>setAsync()</code> (and many others) —  will be regulated by this.</p>
<h5 id="Runnable-Tasks"><a href="#Runnable-Tasks" class="headerlink" title="Runnable Tasks"></a>Runnable Tasks</h5><p>These are simply java runnable objects that are dispatched to one or more members. Keep in mind — the salient part of the signature is <code>public void run()</code> — i.e. nothing is returned. The way that they’re dispatched to the members is very flexible — it can be one member, all members, a member that owns a key, or you can select members by an attribute you have set on them.<br>Here’s an example of running something on all members —</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"runnableDemo"</span>)</span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"client"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemoCaller</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span>, <span class="title">ApplicationContextAware</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        HazelcastInstance client = (HazelcastInstance) applicationContext.getBean(<span class="string">"clientInstance"</span>);</span><br><span class="line">        IExecutorService executorService = client.getExecutorService(<span class="string">"default"</span>);</span><br><span class="line">        executorService.executeOnAllMembers(<span class="keyword">new</span> LoggingRunnable());</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;snip&gt;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>The Runnable object is pretty ordinary, with the caveat that it needs to be serializable. This is an interesting topic and I’m going to touch on it in a minute. This runnable is also <code>HazelcastInstanceAware</code>, so that, when it’s set up on the target node, the Hazelcast framework will inject the correct instance, so that it can communicate with the cluster.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"loggingRunnable"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">HazelcastInstanceAware</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    &lt;snip&gt;</span><br><span class="line">    <span class="keyword">private</span> HazelcastInstance  hazelcastInstance;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        l.info(<span class="string">"into run, cluster size: &#123;&#125;"</span>, getHazelcastInstance().getCluster().getMembers().size());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &lt;snip&gt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>This code wasn’t particularly profound, but there’s one cool aspect to it — you can direct processing to a member that owns a key (or other members) and process that key and or other keys in multiple maps. So, complex manipulation may be performed outside your client, eliminating multiple network round-trips. They data need not come all from one member, either — there are no restrictions on that. It can be a significant performance boost to design your data, so that related items are all within one node — then this kind of task will tend not to make network calls but will not be restricted from doing so.</p>
<h5 id="Callable-Tasks"><a href="#Callable-Tasks" class="headerlink" title="Callable Tasks"></a>Callable Tasks</h5><p>As with runnable, callable tasks are dispatched to one or more members, but offer more options for things like bringing back data.<br>Here’s a really simple callable that will be dispatched to a member, log some noise to show it ran, and return the partition count. There are better ways to monitor or manage partitions, but this should just show how you get a value — easily — from a member.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"runnableDemo"</span>)</span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"client"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemoCaller</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span>, <span class="title">ApplicationContextAware</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        HazelcastInstance client = (HazelcastInstance) applicationContext.getBean(<span class="string">"clientInstance"</span>);</span><br><span class="line">        IExecutorService executorService = client.getExecutorService(<span class="string">"default"</span>);</span><br><span class="line">        executorService.executeOnAllMembers(<span class="keyword">new</span> LoggingRunnable());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &lt;snip&gt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>That is the client code that is executing a <code>LoggingRunnable</code> on each member — here’s the runnable:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"loggingRunnable"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">HazelcastInstanceAware</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    &lt;snip&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        l.info(<span class="string">"into run, cluster size: &#123;&#125;"</span>, getHazelcastInstance().getCluster().getMembers().size());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &lt;snip --- boilerplate&gt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>That’s just looking at the member, which you might want to do. Importantly, If you wanted to get/set/remove data, run a query, or any other Hazelcast operation, you can do that from that code.<br>The call is easy — as with the collections, it draws heavily from the Java Executors API.</p>
<p>Callable Tasks are similar, but allow a value to be returned from each member. If more than one member is involved, a collection of results is returned. Here’s a sample call —</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemoCaller</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span>, <span class="title">ApplicationContextAware</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    &lt;snip&gt;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        HazelcastInstance client = (HazelcastInstance) applicationContext.getBean(<span class="string">"clientInstance"</span>);</span><br><span class="line">        IExecutorService executorService = client.getExecutorService(<span class="string">"default"</span>);</span><br><span class="line"></span><br><span class="line">        Callable&lt;String&gt; demoCallable = <span class="keyword">new</span> DemoCallable();</span><br><span class="line">        l.info(<span class="string">"Submitting this one to all members"</span>);</span><br><span class="line">        Map&lt;Member, Future&lt;String&gt;&gt; results = executorService.submitToAllMembers(demoCallable);</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; result : results.values())</span><br><span class="line">          &#123;</span><br><span class="line">            l.info(<span class="string">"Result from '&#123;&#125;'"</span>, result.get());</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        executorService.executeOnAllMembers(<span class="keyword">new</span> LoggingRunnable());</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;snip&gt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>The callable task just a java class that, at a minimum, implements <code>Callable</code> —</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;, <span class="title">HazelcastInstanceAware</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    &lt;snip&gt;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        InetSocketAddress socketAddress = hazelcastInstance.getCluster().getLocalMember().getSocketAddress();</span><br><span class="line">        String id = String</span><br><span class="line">          .format(<span class="string">"Running in member '%s::%d"</span>, socketAddress.getHostName(), socketAddress.getPort());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;snip&gt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="What-Just-Happened"><a href="#What-Just-Happened" class="headerlink" title="What Just Happened?"></a>What Just Happened?</h3><p>Hard to say, but if you were following along, you’ve created clients and members that start Hazelcast and do useful things. This may be a little more than a simple intro, but it’s also just a little of what you can do with Hazelcast. I hope that you get a few things from this — like how much I like Hazelcast. I’ve been doing distributed systems for what seems like a really long time — anyone still using ARCNet messaging on  MP/M? I hope not; I really do. I’ve done distributed systems before there were cool frameworks like Hazelcast and I’ve used most of the competition, too. This one is my choice — it gives performance and simplicity. You can be up and running in minutes and rolling out production quality code that looks an awful lot like your Java collections code. It’s a fun environment for programmers. A little Java gets can be all you need on the server side, then you can cut loose with Java, .NET, C++, Node.js, Python, Go or Scala — and that list is going to grow, as new languages emerge.<br>But, anyway — we stood up storage members and a couple clients, with a functional subset of features from Hazelcast. There was no production code here, but I think it shows the path.</p>
</div></article></div></main><footer><div class="paginator"></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">Tom O'Connell</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>